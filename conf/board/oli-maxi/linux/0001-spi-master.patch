diff -ruN linux-3.7-rc4/arch/arm/boot/dts/imx23-olinuxino.dts linux/arch/arm/boot/dts/imx23-olinuxino.dts
--- linux-3.7-rc4/arch/arm/boot/dts/imx23-olinuxino.dts	2012-11-04 19:07:39.000000000 +0000
+++ linux/arch/arm/boot/dts/imx23-olinuxino.dts	2012-11-19 12:48:27.253247007 +0000
@@ -24,6 +24,48 @@
 
 	apb@80000000 {
 		apbh@80000000 {
+			ssp1: ssp@80034000 {
+				compatible = "fsl,imx23-spi";
+				clock-frequency = <160000000>;
+				bus-num = <0>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&spi1_control_pins &spi1_cs_pins>;
+				status = "okay";
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				device@0 {
+					compatible = "spidev";
+					reg = <0>;
+					spi-max-frequency = <16000000>;
+					interrupts = <&gpio2 28>;
+					interrupt-names = "spidev-trigger";
+				};
+			};
+			pinctrl@80018000 {
+				spi1_control_pins: spi1_control_pins {
+					reg = <0>;
+					fsl,pinmux-ids = <
+						0x0182 /* MX23_PAD_GPMI_WRN__SSP2_SCK */
+						0x0142 /* MX23_PAD_GPMI_RDY1__SSP2_CMD aka MOSI */
+						0x0002 /* MX23_PAD_GPMI_D00__SSP2_DATA0 aka MISO */
+					>;
+				};
+				spi1_cs_pins: spi1_cs_pins {
+					reg = <0>;
+					fsl,pinmux-ids = <
+						0x1033 /* MX23_PAD_LCD_D03__GPIO_1_3 */
+						/* This is optional, this allows the spidev
+						 * driver to have an interrupt pin, this is
+						 * "Bank 2 pin 28" and it needs a pullup
+						 */
+						0x21c3 /* MX23_PAD_GPMI_CE0N__GPIO_2_28 */
+					>;
+					fsl,pull-up = <1>;
+				};
+			};
+			
 			ssp0: ssp@80010000 {
 				compatible = "fsl,imx23-mmc";
 				pinctrl-names = "default";
@@ -89,6 +131,18 @@
 		};
 	};
 
+	/*
+	 * maxi declares the i2c by default as software -- so instanciate a linux driver
+	 * for it
+	 */
+	i2c@0 {
+		compatible = "i2c-gpio";
+		gpios = <&gpio2 27 0 /* sda */
+			 &gpio2 28 0 /* scl */
+			>;
+		i2c-gpio,delay-us = <2>;	/* ~100 kHz */
+	};
+
 	leds {
 		compatible = "gpio-leds";
 
diff -ruN linux-3.7-rc4/drivers/spi/spidev.c linux/drivers/spi/spidev.c
--- linux-3.7-rc4/drivers/spi/spidev.c	2012-11-04 19:07:39.000000000 +0000
+++ linux/drivers/spi/spidev.c	2012-11-19 13:48:50.397139827 +0000
@@ -24,6 +24,8 @@
 #include <linux/module.h>
 #include <linux/ioctl.h>
 #include <linux/fs.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/list.h>
@@ -31,6 +33,8 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
 
 #include <linux/spi/spi.h>
 #include <linux/spi/spidev.h>
@@ -78,6 +82,7 @@
 	spinlock_t		spi_lock;
 	struct spi_device	*spi;
 	struct list_head	device_entry;
+	wait_queue_head_t irq_queue;
 
 	/* buffer is NULL unless this device is open (users > 0) */
 	struct mutex		buf_lock;
@@ -482,6 +487,22 @@
 #define spidev_compat_ioctl NULL
 #endif /* CONFIG_COMPAT */
 
+/*
+ * Using poll on the spidev device will return a read even when an
+ * (optional) interrupt is triggered. This allows interfacing with
+ * SPi packet radios and other devices that have a parallel way
+ * of signaling the CPU for events
+ */
+static unsigned int spidev_poll(struct file * filp, poll_table *wait)
+{
+	struct spidev_data	*spidev = filp->private_data;
+
+	poll_wait(filp, &spidev->irq_queue, wait);
+
+	return POLLIN | POLLRDNORM;
+}
+
+
 static int spidev_open(struct inode *inode, struct file *filp)
 {
 	struct spidev_data	*spidev;
@@ -558,8 +579,22 @@
 	.open =		spidev_open,
 	.release =	spidev_release,
 	.llseek =	no_llseek,
+	.poll = spidev_poll,
 };
 
+/*
+ * trigger for an (optional) IRQ that will wake up
+ * userland process that waits on poll() or select()
+ */
+static irqreturn_t spidev_notify_irq(int irq, void *dev)
+{
+	struct spidev_data	*spidev;
+
+	wake_up_interruptible(&spidev->irq_queue);
+
+	return IRQ_HANDLED;
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* The main reason to have this class is to make mdev/udev create the
@@ -610,6 +645,12 @@
 		set_bit(minor, minors);
 		list_add(&spidev->device_entry, &device_list);
 	}
+	if (spi->irq) {
+		status = request_threaded_irq(spi->irq, NULL, spidev_notify_irq, 
+					IRQF_ONESHOT, "spidev-irq", spidev);
+		if (status)
+			dev_err(&spi->dev, "warning: unable to get irq: %d\n", status);
+	}
 	mutex_unlock(&device_list_lock);
 
 	if (status == 0)
@@ -642,10 +683,16 @@
 	return 0;
 }
 
+static const struct of_device_id spidev_of_id[] = {
+	{ .compatible = "spidev", },
+	{ /* sentinel */ }
+};
+
 static struct spi_driver spidev_spi_driver = {
 	.driver = {
 		.name =		"spidev",
 		.owner =	THIS_MODULE,
+		.of_match_table = spidev_of_id,
 	},
 	.probe =	spidev_probe,
 	.remove =	__devexit_p(spidev_remove),
diff -ruN linux-3.7-rc4/drivers/spi/spi-mxs.c linux/drivers/spi/spi-mxs.c
--- linux-3.7-rc4/drivers/spi/spi-mxs.c	2012-11-04 19:07:39.000000000 +0000
+++ linux/drivers/spi/spi-mxs.c	2012-11-09 15:13:40.512020419 +0000
@@ -524,6 +524,7 @@
 	int devid, dma_channel, clk_freq;
 	int ret = 0, irq_err, irq_dma;
 	dma_cap_mask_t mask;
+	int bus_num = -1;
 
 	/*
 	 * Default clock speed for the SPI core. 160MHz seems to
@@ -568,6 +569,8 @@
 					   &clk_freq);
 		if (ret)
 			clk_freq = clk_freq_default;
+		if (of_property_read_u32(np, "bus-num", &bus_num))
+			bus_num = -1;
 	} else {
 		dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 		if (!dmares)
@@ -580,7 +583,7 @@
 	master = spi_alloc_master(&pdev->dev, sizeof(*spi));
 	if (!master)
 		return -ENOMEM;
-
+	master->bus_num = bus_num;
 	master->transfer_one_message = mxs_spi_transfer_one;
 	master->setup = mxs_spi_setup;
 	master->mode_bits = SPI_CPOL | SPI_CPHA;
