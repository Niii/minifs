*** linux/arch/arm/mach-s3c2412/mach-df3120.c	2010-12-30 13:00:39.000000000 +0100
--- linux_patch/arch/arm/mach-s3c2412/mach-df3120.c	2010-12-30 10:02:59.000000000 +0100
***************
*** 2,7 ****
--- 2,8 ----
   *
   * (C) 2009 Jeroen Domburg <jeroen@spritesmods.com>
   * (C) 2009 Michel Pollet <buserror@gmail.com>
+  * (C) 2010 Claude Schwarz <claude.schwarz@gmail.com>
   *
   * Derived from mach-vstms.c - (C) 2006 Thomas Gleixner <tglx@linutronix.de>
   * Derived from mach-smdk2413.c - (C) 2006 Simtec Electronics
***************
*** 28,33 ****
--- 29,35 ----
  #include <linux/gpio_keys.h>
  #include <linux/mmc/host.h>
  #include <linux/input.h>
+ #include <linux/delay.h>
  
  #include <asm/mach/arch.h>
  #include <asm/mach/map.h>
***************
*** 106,112 ****
  		.active_low	= 1,
  	},
  	{
! 		.gpio		= S3C2410_GPF(2),
  		.code		= KEY_RIGHT,
  		.desc		= "Right",
  		.active_low	= 1,
--- 108,114 ----
  		.active_low	= 1,
  	},
  	{
! 		.gpio		= S3C2410_GPF(5),
  		.code		= KEY_RIGHT,
  		.desc		= "Right",
  		.active_low	= 1,
***************
*** 293,298 ****
--- 295,348 ----
  #endif
  };
  
+ 
+ static void df3120_bt_init(void)
+ {
+ 	printk(KERN_INFO "Set BCM2045 GPIOs \n");
+ 
+         /* BT nReset active*/
+         s3c2410_gpio_cfgpin(S3C2410_GPF(5), S3C2410_GPIO_OUTPUT);
+         s3c2410_gpio_setpin(S3C2410_GPF(5), 0);
+ 
+         mdelay(50);
+ 
+         /*Keep nRTS high until BT chip is initalized , nCTS input*/
+         s3c2410_gpio_cfgpin(S3C2410_GPH(1), S3C2410_GPIO_OUTPUT);
+         s3c2410_gpio_cfgpin(S3C2410_GPH(0), S3C2410_GPIO_INPUT);
+         s3c2410_gpio_setpin(S3C2410_GPH(1), 1);
+ 
+         mdelay(50);
+ 
+         /* BT nReset inactive*/
+         s3c2410_gpio_setpin(S3C2410_GPF(5), 1);
+ 
+         mdelay (50);
+ 
+         /* BT BT_Wake active*/
+         s3c2410_gpio_cfgpin(S3C2410_GPF(1), S3C2410_GPIO_OUTPUT);
+         s3c2410_gpio_setpin(S3C2410_GPF(1), 1);
+ 
+         /* BT HOST_Wake as input*/
+         s3c2410_gpio_cfgpin(S3C2410_GPF(0), S3C2410_GPIO_INPUT);
+ 
+         mdelay (500);
+ 	
+ 	/* UART flow controll , hardwired */
+         s3c2410_gpio_setpin(S3C2410_GPH(1), 0);
+ 
+ 	/* Uart flow controll , through S3C's AFC */
+         /*
+ 	void __iomem *regs = S3C_VA_UARTx(0);
+         int reg = __raw_readl(regs + S3C2410_UMCON);
+         __raw_writel(reg | S3C2410_UMCOM_AFC | S3C2412_UMCON_AFC_8, regs + S3C2410_UMCON);
+ 
+         s3c2410_gpio_cfgpin(S3C2410_GPH(1), S3C2410_GPH1_nRTS0);
+         s3c2410_gpio_cfgpin(S3C2410_GPH(0), S3C2410_GPH0_nCTS0);
+ 	*/
+ }
+ 
+ 	
+ 
  static int df3120_bl_init(struct device *dev)
  {
  	int ret=0;
***************
*** 394,410 ****
  	&df3120_button_device,
  };
  
- static void __init df3120_fixup(struct machine_desc *desc,
- 				  struct tag *tags, char **cmdline,
- 				  struct meminfo *mi)
- {
- 	if (tags != phys_to_virt(S3C2410_SDRAM_PA + 0x100)) {
- 		mi->nr_banks=1;
- 		mi->bank[0].start = 0x30000000;
- 		mi->bank[0].size = SZ_8M;
- 	}
- }
- 
  static void __init df3120_map_io(void)
  {
  	s3c_device_nand.dev.platform_data = &df3120_nand_info;
--- 444,449 ----
***************
*** 422,435 ****
  	s3c24xx_fb_set_platdata(&df3120_fb_info);
  	s3c24xx_udc_set_platdata(&df3120_udc_cfg);
  	platform_add_devices(df3120_devices, ARRAY_SIZE(df3120_devices));
  }
  
  MACHINE_START(DF3120, "DF3120")
  	.phys_io	= S3C2410_PA_UART,
  	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
  	.boot_params	= S3C2410_SDRAM_PA + 0x100,
- 
- 	.fixup		= df3120_fixup,
  	.init_irq	= s3c24xx_init_irq,
  	.init_machine	= df3120_init,
  	.map_io		= df3120_map_io,
--- 461,473 ----
  	s3c24xx_fb_set_platdata(&df3120_fb_info);
  	s3c24xx_udc_set_platdata(&df3120_udc_cfg);
  	platform_add_devices(df3120_devices, ARRAY_SIZE(df3120_devices));
+ 	df3120_bt_init();
  }
  
  MACHINE_START(DF3120, "DF3120")
  	.phys_io	= S3C2410_PA_UART,
  	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
  	.boot_params	= S3C2410_SDRAM_PA + 0x100,
  	.init_irq	= s3c24xx_init_irq,
  	.init_machine	= df3120_init,
  	.map_io		= df3120_map_io,
